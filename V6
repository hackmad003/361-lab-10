#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
#include <string.h>

#include "lab10.h"


extern char * dishes[];

static int served_customers;

static int customer_waiting = -1;

static pthread_mutex_t customer_waiting_lock;

static pthread_cond_t customer_ready;

static int customer_seated = -1;
static pthread_cond_t customer_seated_cond;

static int customer_order = -1;
static pthread_cond_t order_placed_cond;

static int food_delivered = -1;
static pthread_cond_t order_placed_cond;
static int food_delivered = -1;
static pthread_cond_t food_delivered_cond;
static int service_complete = -1;
static pthread_cond_t service_complete_cond;


void initialize(void)
{
    // add initializations here
    pthread_mutex_init(&customer_waiting_lock, NULL);
    pthread_cond_init(&customer_ready, NULL);
    pthread_cond_init(&customer_seated_cond, NULL);
    pthread_cond_init(&order_placed_cond, NULL);
    pthread_cond_init(&food_delivered_cond, NULL);
    pthread_cond_init(&service_completed_cond, NULL);

}

void customer(int id, int dish)
{
    // signal customer ready to be served
    ready_to_seat_customer(id);

    pthread_mutex_lock(&customer_waiting_lock);

    // TODO 1: try to get ownership of the lock
    customer_waiting = id;

    // TODO 2: Signal to the waiter that customer is waiting
    pthread_cond_signal(&customer_ready);


    while(customer_seated == -1)
        pthread_cond_wait(&customer_seated_cond, &customer_waiting_lock);
    customer_seated = -1;

    pthread_mutex_unlock(&customer_waiting_lock);


    // TODO: 4 Wait to be seated

    // TODO: 6 place order and signal waiter
    pthread_mutex_lock(&customer_waiting_lock);
    order_placed_by_customer(id, dish);

    customer_order = dish;

    pthread_cond_signal(&order_placed_cond);
    pthread_mutex_unlock(&customer_waiting_lock);

    // TODO 7: wait for order to be delivered
    pthread_mutex_lock(&customer_waiting_lock);
    while(food_delivered == -1)
        pthread_cond_wait(&food_delivered_cond, &customer_waiting_lock);
    food_delivered = -1;
    pthread_mutex_unlock(&customer_waiting_lock);

    pthread_mutex_lock(&customer_waiting_lock);
    service_completed_for_customer(id);
    service_complete = 1;
    pthread_cond_signal(&service_complete_cond);
    pthread_mutex_unlock(&customer_waiting_lock);

    // TODO 8: signal to waiter that the customer is done
}


void waiter(void)
{
    if (served_customers >= MAX_CUSTOMERS)
        return;

    // seat waiting customer

    // TODO 3: replace busy loop with predicate/cond_wait construct
    pthread_mutex_lock(&customer_waiting_lock);
    while (customer_waiting == -1)
        pthread_cond_wait(&customer_ready, &customer_waiting_lock);
    int customer = customer_waiting;


    // TODO 5: seat the customer and then signal the customer thread
    seat_customer(customer);
    customer_seated = 1;
    pthread_cond_signal(&customer_seated_cond);
    pthread_mutex_unlock(&customer_waiting_lock);

    // TODO 6: wait for customer to place order then determine the order number
    pthread_mutex_lock(&customer_waiting_lock);
    while(customer_order == -1)
        pthread_cond_wait(&order_placed_cond, &customer_waiting_lock);
    int dish = customer_order;
    customer_order = -1;
    pthread_mutex_unlock(&customer_waiting_lock);


    pthread_mutex_lock(&customer_waiting_lock);
    bring_food_to_customer(customer, dish);
    food_delivered = 1;
    pthread_cond_signal(&food_delivered_cond);
    pthread_mutex_unlock(&customer_waiting_lock);

   pthread_mutex_lock(&customer_waiting_lock);
    while(service_complete == -1)
        pthread_cond_wait(&service_complete_cond, &customer_waiting_lock);
    service_complete = -1;
    pthread_mutex_unlock(&customer_waiting_lock);

    //bring_food_to_customer(customer, dish); // second arg should be zero in starter

    served_customers++;
}


